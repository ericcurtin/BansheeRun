// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`

/// Get banshee position for a recorded run at a given elapsed time
Future<BansheeStateDto> getRecordedBansheePosition({
  required String runId,
  required PlatformInt64 elapsedMs,
}) => RustLib.instance.api.crateApiBansheeApiGetRecordedBansheePosition(
  runId: runId,
  elapsedMs: elapsedMs,
);

/// Get AI pacer position given start point, target pace, and elapsed time
/// The pacer follows the provided route if given, otherwise moves in a straight line
Future<BansheeStateDto> getAiPacerPosition({
  required double startLat,
  required double startLon,
  required double targetPaceSecPerKm,
  required PlatformInt64 elapsedMs,
  List<(double, double)>? route,
}) => RustLib.instance.api.crateApiBansheeApiGetAiPacerPosition(
  startLat: startLat,
  startLon: startLon,
  targetPaceSecPerKm: targetPaceSecPerKm,
  elapsedMs: elapsedMs,
  route: route,
);

/// Calculate banshee state relative to runner
BansheeStateDto calculateBansheeDelta({
  required double bansheeDistanceM,
  required PlatformInt64 bansheeTimeMs,
  required double runnerDistanceM,
  required PlatformInt64 runnerTimeMs,
  double? targetPaceSecPerKm,
}) => RustLib.instance.api.crateApiBansheeApiCalculateBansheeDelta(
  bansheeDistanceM: bansheeDistanceM,
  bansheeTimeMs: bansheeTimeMs,
  runnerDistanceM: runnerDistanceM,
  runnerTimeMs: runnerTimeMs,
  targetPaceSecPerKm: targetPaceSecPerKm,
);

/// Format banshee delta for display (e.g., "50m behind", "100m ahead")
String formatBansheeDelta({required double distanceDeltaMeters}) =>
    RustLib.instance.api.crateApiBansheeApiFormatBansheeDelta(
      distanceDeltaMeters: distanceDeltaMeters,
    );

/// Check if the runner has crossed the ahead/behind threshold
/// Returns: -1 if now behind (was ahead), 1 if now ahead (was behind), 0 if no change
int checkPositionChange({
  required double previousDeltaM,
  required double currentDeltaM,
  required double thresholdM,
}) => RustLib.instance.api.crateApiBansheeApiCheckPositionChange(
  previousDeltaM: previousDeltaM,
  currentDeltaM: currentDeltaM,
  thresholdM: thresholdM,
);

/// Generate common pace targets (returns pace in sec/km and display name)
List<(double, String)> getPacePresets() =>
    RustLib.instance.api.crateApiBansheeApiGetPacePresets();

/// DTO for banshee state returned to Flutter
class BansheeStateDto {
  final double lat;
  final double lon;
  final double distanceMeters;
  final PlatformInt64 timeDeltaMs;
  final double distanceDeltaMeters;

  const BansheeStateDto({
    required this.lat,
    required this.lon,
    required this.distanceMeters,
    required this.timeDeltaMs,
    required this.distanceDeltaMeters,
  });

  @override
  int get hashCode =>
      lat.hashCode ^
      lon.hashCode ^
      distanceMeters.hashCode ^
      timeDeltaMs.hashCode ^
      distanceDeltaMeters.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BansheeStateDto &&
          runtimeType == other.runtimeType &&
          lat == other.lat &&
          lon == other.lon &&
          distanceMeters == other.distanceMeters &&
          timeDeltaMs == other.timeDeltaMs &&
          distanceDeltaMeters == other.distanceDeltaMeters;
}
